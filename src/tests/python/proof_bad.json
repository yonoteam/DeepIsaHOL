{
  "proof": {
    "steps": [
      {
      "step": {
        "action": "lemma sat_the_restrict: "fv \\<phi> \\<subseteq> A \\<Longrightarrow> MFOTL.sat \\<sigma> (map the (restrict A v)) i \\<phi> = MFOTL.sat \\<sigma> (map the v) i \\<phi>",
        "user_state": "",
        "term": "(fv \\<phi> \\<subseteq> A \\<Longrightarrow> MFOTL.sat \\<sigma> (map the (restrict A v)) i \\<phi> = MFOTL.sat \\<sigma> (map the v) i \\<phi>) \\<Longrightarrow> (fv \\<phi> \\<subseteq> A \\<Longrightarrow> MFOTL.sat \\<sigma> (map the (restrict A v)) i \\<phi> = MFOTL.sat \\<sigma> (map the v) i \\<phi>)",
        "hyps": [
          
        ],
        "proven": [
          
        ],
        "variables": [
          {"Type0": "i :: nat"},
          {"Type1": "v :: 'a option list"},
          {"Type2": "\\<sigma> :: (char list \\<times> 'a list) trace"},
          {"Type3": "A :: nat set"},
          {"Type4": "\\<phi> :: 'a MFOTL.formula"}
        ],
        "constants": [
          {"Type0": "Pure.prop :: prop \\<Rightarrow> prop"},
          {"Type1": "restrict :: nat set \\<Rightarrow> 'a option list \\<Rightarrow> 'a option list"},
          {"Type2": "the :: 'a option \\<Rightarrow> 'a"},
          {"Type3": "map :: ('a option \\<Rightarrow> 'a) \\<Rightarrow> 'a option list \\<Rightarrow> 'a list"},
          {"Type4": "MFOTL.sat :: (char list \\<times> 'a list) trace \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> 'a MFOTL.formula \\<Rightarrow> bool"},
          {"Type5": "(=) :: bool \\<Rightarrow> bool \\<Rightarrow> bool"},
          {"Type6": "0 :: nat"},
          {"Type7": "MFOTL.fvi :: nat \\<Rightarrow> 'a MFOTL.formula \\<Rightarrow> nat set"},
          {"Type8": "(\\<subseteq>) :: nat set \\<Rightarrow> nat set \\<Rightarrow> bool"},
          {"Type9": "Trueprop :: bool \\<Rightarrow> prop"},
          {"Type10": "(\\<Longrightarrow>) :: prop \\<Rightarrow> prop \\<Rightarrow> prop"}
        ],
        "type variables": [
          {"Sort0": "'a :: type"}
        ]
      }
    },
      {
      "step": {
        "action": "by (rule sat_fvi_cong) (auto intro!: map_the_restrict)",
        "user_state": "proof (prove)  goal (1 subgoal):   1. fv \\<phi> \\<subseteq> A \\<Longrightarrow> MFOTL.sat \\<sigma> (map the (restrict A v)) i \\<phi> = MFOTL.sat \\<sigma> (map the v) i \\<phi>",
        "term": "(fv \\<phi> \\<subseteq> A \\<Longrightarrow> MFOTL.sat \\<sigma> (map the (restrict A v)) i \\<phi> = MFOTL.sat \\<sigma> (map the v) i \\<phi>) \\<Longrightarrow> (fv \\<phi> \\<subseteq> A \\<Longrightarrow> MFOTL.sat \\<sigma> (map the (restrict A v)) i \\<phi> = MFOTL.sat \\<sigma> (map the v) i \\<phi>)",
        "hyps": [
          
        ],
        "proven": [
          
        ],
        "variables": [
          {"Type0": "i :: nat"},
          {"Type1": "v :: 'a option list"},
          {"Type2": "\\<sigma> :: (char list \\<times> 'a list) trace"},
          {"Type3": "A :: nat set"},
          {"Type4": "\\<phi> :: 'a MFOTL.formula"}
        ],
        "constants": [
          {"Type0": "Pure.prop :: prop \\<Rightarrow> prop"},
          {"Type1": "restrict :: nat set \\<Rightarrow> 'a option list \\<Rightarrow> 'a option list"},
          {"Type2": "the :: 'a option \\<Rightarrow> 'a"},
          {"Type3": "map :: ('a option \\<Rightarrow> 'a) \\<Rightarrow> 'a option list \\<Rightarrow> 'a list"},
          {"Type4": "MFOTL.sat :: (char list \\<times> 'a list) trace \\<Rightarrow> 'a list \\<Rightarrow> nat \\<Rightarrow> 'a MFOTL.formula \\<Rightarrow> bool"},
          {"Type5": "(=) :: bool \\<Rightarrow> bool \\<Rightarrow> bool"},
          {"Type6": "0 :: nat"},
          {"Type7": "MFOTL.fvi :: nat \\<Rightarrow> 'a MFOTL.formula \\<Rightarrow> nat set"},
          {"Type8": "(\\<subseteq>) :: nat set \\<Rightarrow> nat set \\<Rightarrow> bool"},
          {"Type9": "Trueprop :: bool \\<Rightarrow> prop"},
          {"Type10": "(\\<Longrightarrow>) :: prop \\<Rightarrow> prop \\<Rightarrow> prop"}
        ],
        "type variables": [
          {"Sort0": "'a :: type"}
        ]
      }
    }
    ],
    "apply_kwrds": [
      {"name": "\\<proof>"},
      {"name": "sorry"},
      {"name": "by"},
      {"name": ".."},
      {"name": "."},
      {"name": "unfolding"},
      {"name": "including"},
      {"name": "using"},
      {"name": "apply_end"},
      {"name": "supply"},
      {"name": "prefer"},
      {"name": "defer"},
      {"name": "apply"},
      {"name": "back"},
      {"name": "done"},
      {"name": "oops"},
      {"name": "proof"},
      {"name": "subgoal"}
    ],
    "isar_kwrds": [
      {"name": "{"},
      {"name": "}"},
      {"name": "presume"},
      {"name": "define"},
      {"name": "assume"},
      {"name": "case"},
      {"name": "fix"},
      {"name": "moreover"},
      {"name": "include"},
      {"name": "ML_prf"},
      {"name": "write"},
      {"name": "note"},
      {"name": "also"},
      {"name": "let"},
      {"name": "ultimately"},
      {"name": "finally"},
      {"name": "with"},
      {"name": "then"},
      {"name": "from"},
      {"name": "interpret"},
      {"name": "consider"},
      {"name": "hence"},
      {"name": "have"},
      {"name": "next"},
      {"name": "obtain"},
      {"name": "thus"},
      {"name": "show"},
      {"name": "proof"}
    ],
    "methods": [
      {"name": "Quotient.partiality_descending_setup"},
      {"name": "Transfer.transfer_prover_start"},
      {"name": "Quotient.partiality_descending"},
      {"name": "Transfer.transfer_prover_end"},
      {"name": "Countable.countable_datatype"},
      {"name": "Transitive_Closure.rtranclp"},
      {"name": "Fun_Def.lexicographic_order"},
      {"name": "Transitive_Closure.tranclp"},
      {"name": "Transitive_Closure.rtrancl"},
      {"name": "Transitive_Closure.trancl"},
      {"name": "Quotient.descending_setup"},
      {"name": "Transfer.transfer_start'"},
      {"name": "Transfer.transfer_prover"},
      {"name": "Fun_Def.pat_completeness"},
      {"name": "Fun_Def.induction_schema"},
      {"name": "Code_Generator.code_simp"},
      {"name": "Transfer.transfer_start"},
      {"name": "Transfer.transfer_step"},
      {"name": "Quotient.lifting_setup"},
      {"name": "Groebner_Basis.algebra"},
      {"name": "Filter.eventually_elim"},
      {"name": "Transfer.transfer_end"},
      {"name": "Presburger.presburger"},
      {"name": "Ctr_Sugar.coinduction"},
      {"name": "Quotient.regularize"},
      {"name": "Quotient.descending"},
      {"name": "Pure.unfold_locales"},
      {"name": "Inductive.ind_cases"},
      {"name": "Fun_Def.size_change"},
      {"name": "Transfer.transfer'"},
      {"name": "Quotient.injection"},
      {"name": "Pure.intro_locales"},
      {"name": "Pure.intro_classes"},
      {"name": "Transfer.transfer"},
      {"name": "Quotient.cleaning"},
      {"name": "HOL.normalization"},
      {"name": "HOL.hypsubst_thin"},
      {"name": "HOL.contradiction"},
      {"name": "Quotient.lifting"},
      {"name": "Pure.subgoal_tac"},
      {"name": "HOL.clarify_step"},
      {"name": "HOL.atomize_elim"},
      {"name": "Fun_Def.relation"},
      {"name": "Pure.rotate_tac"},
      {"name": "Pure.rename_tac"},
      {"name": "Pure.raw_tactic"},
      {"name": "Pure.goal_cases"},
      {"name": "Pure.assumption"},
      {"name": "Orderings.order"},
      {"name": "HOL.simplesubst"},
      {"name": "Fields.linarith"},
      {"name": "Pure.subproofs"},
      {"name": "Pure.frule_tac"},
      {"name": "Pure.erule_tac"},
      {"name": "Pure.drule_tac"},
      {"name": "HOL.induct_tac"},
      {"name": "Pure.thin_tac"},
      {"name": "Pure.standard"},
      {"name": "Pure.simp_all"},
      {"name": "Pure.rule_tac"},
      {"name": "HOL.slow_step"},
      {"name": "HOL.safe_step"},
      {"name": "HOL.inst_step"},
      {"name": "HOL.induction"},
      {"name": "HOL.fastforce"},
      {"name": "Pure.succeed"},
      {"name": "Pure.cut_tac"},
      {"name": "Pure.atomize"},
      {"name": "HOL.standard"},
      {"name": "HOL.slowsimp"},
      {"name": "HOL.simp_all"},
      {"name": "HOL.hypsubst"},
      {"name": "HOL.coinduct"},
      {"name": "HOL.coherent"},
      {"name": "HOL.clarsimp"},
      {"name": "HOL.case_tac"},
      {"name": "HOL.bestsimp"},
      {"name": "Rings.arith"},
      {"name": "Pure.unfold"},
      {"name": "Pure.tactic"},
      {"name": "Pure.insert"},
      {"name": "Metis.metis"},
      {"name": "Meson.meson"},
      {"name": "HOL.iprover"},
      {"name": "HOL.clarify"},
      {"name": "Pure.sleep"},
      {"name": "Pure.intro"},
      {"name": "Pure.frule"},
      {"name": "Pure.erule"},
      {"name": "Pure.drule"},
      {"name": "HOL.induct"},
      {"name": "HOL.deepen"},
      {"name": "SMT.moura"},
      {"name": "Pure.this"},
      {"name": "Pure.simp"},
      {"name": "Pure.rule"},
      {"name": "Pure.fold"},
      {"name": "Pure.fail"},
      {"name": "Pure.fact"},
      {"name": "Pure.elim"},
      {"name": "HOL.subst"},
      {"name": "HOL.split"},
      {"name": "HOL.force"},
      {"name": "HOL.cases"},
      {"name": "HOL.blast"},
      {"name": "Argo.argo"},
      {"name": "SAT.satx"},
      {"name": "Pure.use"},
      {"name": "HOL.step"},
      {"name": "HOL.slow"},
      {"name": "HOL.simp"},
      {"name": "HOL.safe"},
      {"name": "HOL.rule"},
      {"name": "HOL.fast"},
      {"name": "HOL.eval"},
      {"name": "HOL.best"},
      {"name": "HOL.auto"},
      {"name": "SMT.smt"},
      {"name": "SAT.sat"},
      {"name": "Pure.-"}
    ],
    "deps": [
      {"thm": {"name": "Pure.protectIPure.protectI", "term": "PROP ?A \\<Longrightarrow> (PROP ?A)"}},
      {"thm": {"name": "Pure.protectDPure.protectD", "term": "(PROP ?A) \\<Longrightarrow> PROP ?A"}},
      {"thm": {"name": "HOL.notEHOL.notE", "term": "\\<lbrakk>\\<not> ?P; ?P\\<rbrakk> \\<Longrightarrow> ?R"}},
      {"thm": {"name": "Set.ballISet.ballI", "term": "(\\<And>x. x \\<in> ?A \\<Longrightarrow> ?P x) \\<Longrightarrow> \\<forall>x\\<in>?A. ?P x"}},
      {"thm": {"name": "Set.subsetCESet.subsetCE", "term": "\\<lbrakk>?A \\<subseteq> ?B; ?c \\<notin> ?A \\<Longrightarrow> ?P; ?c \\<in> ?B \\<Longrightarrow> ?P\\<rbrakk> \\<Longrightarrow> ?P"}},
      {"thm": {"name": "Nat.arity_type_natNat.arity_type_nat", "term": "OFCLASS(nat, type_class)"}},
      {"thm": {"name": "Table.map_the_restrictTable.map_the_restrict", "term": "?i \\<in> ?A \\<Longrightarrow> map the (restrict ?A ?v) ! ?i = map the ?v ! ?i"}},
      {"thm": {"name": "MFOTL.sat_fvi_congMFOTL.sat_fvi_cong", "term": "\\<forall>x\\<in>fv ?\\<phi>. ?v ! x = ?v' ! x \\<Longrightarrow> MFOTL.sat ?\\<sigma> ?v ?i ?\\<phi> = MFOTL.sat ?\\<sigma> ?v' ?i ?\\<phi>"}}
    ]
  }
}
